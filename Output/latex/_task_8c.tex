\hypertarget{_task_8c}{}\doxysection{Task.\+c File Reference}
\label{_task_8c}\index{Task.c@{Task.c}}
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$ctype.\+h$>$}\newline
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_tree_node}{Tree\+Node}}
\begin{DoxyCompactList}\small\item\em Creating a structure with left and right leaves. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max}}~100
\begin{DoxyCompactList}\small\item\em We chose to use C because of the fact that There is no proper implementation in C before this and we thought it would be a good learning experience for us if we use our CP knowledge and put it to use here instead of learning C++ again and shifting to another language. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \mbox{\hyperlink{struct_tree_node}{Tree\+Node}} \mbox{\hyperlink{_task_8c_aba028b9fa75702386100892732a4e800}{Tree\+Node}}
\begin{DoxyCompactList}\small\item\em Creating a structure with left and right leaves. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{_task_8c_a8afd80be6cfb73e36bf48de6a8c1dd6c}{calc\+Max}} (int a, int b)
\begin{DoxyCompactList}\small\item\em Helper Function\+: \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max()}} A function to find the max of 2 numbers. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_task_8c_a2b483497092966998b1335924dfa6442}{priority}} (char op)
\begin{DoxyCompactList}\small\item\em Make a if-\/else function for precedence of operators. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_task_8c_aed61586067826b285a214c9643d2c796}{stack\+Push}} (char val)
\begin{DoxyCompactList}\small\item\em Function to push onto stack. \end{DoxyCompactList}\item 
char \mbox{\hyperlink{_task_8c_aed34a437ccad598623ff35ce06b759dc}{stack\+Pop}} ()
\begin{DoxyCompactList}\small\item\em Function to pop from the stack. Exception Case where we might have an empty stack. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_task_8c_a328d06e919f031e5305bf079c3b1ec32}{stack\+Is\+Empty}} ()
\begin{DoxyCompactList}\small\item\em A function to check if stack is empty or not. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_task_8c_a42c6cde842c5416b53b9a0211894e764}{in\+Fix\+To\+Pre\+Fix}} (char $\ast$input)
\begin{DoxyCompactList}\small\item\em Key Rule is We cannot have a lower precedence operator on top of a higher precedence operator Also we cannot have 2 same precedence operators together So we have to keep popping and adding into output If we have a closing bracket we have to pop But again through this method we get Postfix so we reverse the string inorder to get the reverse of preorder notation First we replace ( with ) and ) with ( And in the end we reverse again. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{_task_8c_a361116e1fb6837a1384c240b3659df98}{convert\+Pre\+Order\+To\+Tree}} (\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$$\ast$root, char $\ast$start)
\begin{DoxyCompactList}\small\item\em We observe that from the prefix notation, we can directly get tree If we observe, it starts with an operator and goes on until it gets another operator Let us try if we can get tree from here References \+: \href{https://www.geeksforgeeks.org/building-expression-tree-from-prefix-expression/}{\texttt{ https\+://www.\+geeksforgeeks.\+org/building-\/expression-\/tree-\/from-\/prefix-\/expression/}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_task_8c_a313ba20caa46358af4cc9e665ec9b532}{print\+In\+Order}} (\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$root)
\begin{DoxyCompactList}\small\item\em Function to traverse through the tree in order. We know that in order means first the pointer goes to the left node, then prints the current node and then goes to the right node again using simple recursion we get the following function. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_task_8c_a73d0c0208c597205872452be77f669cc}{max\+Height\+Of\+Parse\+Tree}} (\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$root)
\begin{DoxyCompactList}\small\item\em We need to find max height of tree. We can use Depth First Search for this, i.\+e. we keep traversing lower into the tree until we find an end and we take max of this For example, let\textquotesingle{}s say we have 4 3 5 2 6 1 Here we start from 4, then we say that height is \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max(left\+Sub\+Tree\+Height, right\+Sub\+Tree\+Height)}} + 1 That extra 1 due to the current node itself When we go to the left node, we get that it is \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max(left\+Sub\+Tree\+Height, right\+Sub\+Tree\+Height)}} + 1 again. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_task_8c_af8cfe1853f9906165524e57444d88f47}{recursive\+Truth\+Evaluator}} (char operation, \mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$left, \mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$right)
\begin{DoxyCompactList}\small\item\em Evaluating the truth value of propositional logic formula in a bottoms up fashion. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_task_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}} ()
\begin{DoxyCompactList}\small\item\em Takes input from user Creates a string for the input Create a root and call the function which returns inorder notation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
char \mbox{\hyperlink{_task_8c_ae24cff811e071e4fe46eff231506df71}{stack}} \mbox{[}\mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max}}\mbox{]}
\begin{DoxyCompactList}\small\item\em Create a stack to keep track of operators. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{_task_8c_af93f4f37fc2ad9c37af4a715423b110c}{top}} = -\/1
\item 
int \mbox{\hyperlink{_task_8c_ac0744ec81e8bd93d084359202d422199}{no\+Of\+Characters}} = 0
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}\label{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}} 
\index{Task.c@{Task.c}!max@{max}}
\index{max@{max}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{max}{max}}
{\footnotesize\ttfamily \#define max~100}



We chose to use C because of the fact that There is no proper implementation in C before this and we thought it would be a good learning experience for us if we use our CP knowledge and put it to use here instead of learning C++ again and shifting to another language. 

Define a constant to take care of max limit of input 

\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{_task_8c_aba028b9fa75702386100892732a4e800}\label{_task_8c_aba028b9fa75702386100892732a4e800}} 
\index{Task.c@{Task.c}!TreeNode@{TreeNode}}
\index{TreeNode@{TreeNode}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{TreeNode}{TreeNode}}
{\footnotesize\ttfamily typedef struct \mbox{\hyperlink{struct_tree_node}{Tree\+Node}} \mbox{\hyperlink{struct_tree_node}{Tree\+Node}}}



Creating a structure with left and right leaves. 



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_task_8c_a8afd80be6cfb73e36bf48de6a8c1dd6c}\label{_task_8c_a8afd80be6cfb73e36bf48de6a8c1dd6c}} 
\index{Task.c@{Task.c}!calcMax@{calcMax}}
\index{calcMax@{calcMax}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{calcMax()}{calcMax()}}
{\footnotesize\ttfamily int calc\+Max (\begin{DoxyParamCaption}\item[{int}]{a,  }\item[{int}]{b }\end{DoxyParamCaption})}



Helper Function\+: \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max()}} A function to find the max of 2 numbers. 

\mbox{\Hypertarget{_task_8c_a361116e1fb6837a1384c240b3659df98}\label{_task_8c_a361116e1fb6837a1384c240b3659df98}} 
\index{Task.c@{Task.c}!convertPreOrderToTree@{convertPreOrderToTree}}
\index{convertPreOrderToTree@{convertPreOrderToTree}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{convertPreOrderToTree()}{convertPreOrderToTree()}}
{\footnotesize\ttfamily char $\ast$ convert\+Pre\+Order\+To\+Tree (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$$\ast$}]{root,  }\item[{char $\ast$}]{start }\end{DoxyParamCaption})}



We observe that from the prefix notation, we can directly get tree If we observe, it starts with an operator and goes on until it gets another operator Let us try if we can get tree from here References \+: \href{https://www.geeksforgeeks.org/building-expression-tree-from-prefix-expression/}{\texttt{ https\+://www.\+geeksforgeeks.\+org/building-\/expression-\/tree-\/from-\/prefix-\/expression/}}. 


\begin{DoxyParams}{Parameters}
{\em root} & \\
\hline
{\em start} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
char$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_a42c6cde842c5416b53b9a0211894e764}\label{_task_8c_a42c6cde842c5416b53b9a0211894e764}} 
\index{Task.c@{Task.c}!inFixToPreFix@{inFixToPreFix}}
\index{inFixToPreFix@{inFixToPreFix}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{inFixToPreFix()}{inFixToPreFix()}}
{\footnotesize\ttfamily void in\+Fix\+To\+Pre\+Fix (\begin{DoxyParamCaption}\item[{char $\ast$}]{input }\end{DoxyParamCaption})}



Key Rule is We cannot have a lower precedence operator on top of a higher precedence operator Also we cannot have 2 same precedence operators together So we have to keep popping and adding into output If we have a closing bracket we have to pop But again through this method we get Postfix so we reverse the string inorder to get the reverse of preorder notation First we replace ( with ) and ) with ( And in the end we reverse again. 


\begin{DoxyParams}{Parameters}
{\em input} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_task_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}\label{_task_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}} 
\index{Task.c@{Task.c}!main@{main}}
\index{main@{main}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Takes input from user Creates a string for the input Create a root and call the function which returns inorder notation. 

\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_a73d0c0208c597205872452be77f669cc}\label{_task_8c_a73d0c0208c597205872452be77f669cc}} 
\index{Task.c@{Task.c}!maxHeightOfParseTree@{maxHeightOfParseTree}}
\index{maxHeightOfParseTree@{maxHeightOfParseTree}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{maxHeightOfParseTree()}{maxHeightOfParseTree()}}
{\footnotesize\ttfamily int max\+Height\+Of\+Parse\+Tree (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$}]{root }\end{DoxyParamCaption})}



We need to find max height of tree. We can use Depth First Search for this, i.\+e. we keep traversing lower into the tree until we find an end and we take max of this For example, let\textquotesingle{}s say we have 4 3 5 2 6 1 Here we start from 4, then we say that height is \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max(left\+Sub\+Tree\+Height, right\+Sub\+Tree\+Height)}} + 1 That extra 1 due to the current node itself When we go to the left node, we get that it is \mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max(left\+Sub\+Tree\+Height, right\+Sub\+Tree\+Height)}} + 1 again. 


\begin{DoxyParams}{Parameters}
{\em root} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_a313ba20caa46358af4cc9e665ec9b532}\label{_task_8c_a313ba20caa46358af4cc9e665ec9b532}} 
\index{Task.c@{Task.c}!printInOrder@{printInOrder}}
\index{printInOrder@{printInOrder}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{printInOrder()}{printInOrder()}}
{\footnotesize\ttfamily void print\+In\+Order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$}]{root }\end{DoxyParamCaption})}



Function to traverse through the tree in order. We know that in order means first the pointer goes to the left node, then prints the current node and then goes to the right node again using simple recursion we get the following function. 


\begin{DoxyParams}{Parameters}
{\em root} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{_task_8c_a2b483497092966998b1335924dfa6442}\label{_task_8c_a2b483497092966998b1335924dfa6442}} 
\index{Task.c@{Task.c}!priority@{priority}}
\index{priority@{priority}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{priority()}{priority()}}
{\footnotesize\ttfamily int priority (\begin{DoxyParamCaption}\item[{char}]{op }\end{DoxyParamCaption})}



Make a if-\/else function for precedence of operators. 


\begin{DoxyParams}{Parameters}
{\em op} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_af8cfe1853f9906165524e57444d88f47}\label{_task_8c_af8cfe1853f9906165524e57444d88f47}} 
\index{Task.c@{Task.c}!recursiveTruthEvaluator@{recursiveTruthEvaluator}}
\index{recursiveTruthEvaluator@{recursiveTruthEvaluator}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{recursiveTruthEvaluator()}{recursiveTruthEvaluator()}}
{\footnotesize\ttfamily int recursive\+Truth\+Evaluator (\begin{DoxyParamCaption}\item[{char}]{operation,  }\item[{\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$}]{left,  }\item[{\mbox{\hyperlink{struct_tree_node}{Tree\+Node}} $\ast$}]{right }\end{DoxyParamCaption})}



Evaluating the truth value of propositional logic formula in a bottoms up fashion. 


\begin{DoxyParams}{Parameters}
{\em operation} & \\
\hline
{\em left} & \\
\hline
{\em right} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_a328d06e919f031e5305bf079c3b1ec32}\label{_task_8c_a328d06e919f031e5305bf079c3b1ec32}} 
\index{Task.c@{Task.c}!stackIsEmpty@{stackIsEmpty}}
\index{stackIsEmpty@{stackIsEmpty}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{stackIsEmpty()}{stackIsEmpty()}}
{\footnotesize\ttfamily int stack\+Is\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



A function to check if stack is empty or not. 

\begin{DoxyReturn}{Returns}
int 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_aed34a437ccad598623ff35ce06b759dc}\label{_task_8c_aed34a437ccad598623ff35ce06b759dc}} 
\index{Task.c@{Task.c}!stackPop@{stackPop}}
\index{stackPop@{stackPop}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{stackPop()}{stackPop()}}
{\footnotesize\ttfamily char stack\+Pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Function to pop from the stack. Exception Case where we might have an empty stack. 

\begin{DoxyReturn}{Returns}
char 
\end{DoxyReturn}
\mbox{\Hypertarget{_task_8c_aed61586067826b285a214c9643d2c796}\label{_task_8c_aed61586067826b285a214c9643d2c796}} 
\index{Task.c@{Task.c}!stackPush@{stackPush}}
\index{stackPush@{stackPush}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{stackPush()}{stackPush()}}
{\footnotesize\ttfamily void stack\+Push (\begin{DoxyParamCaption}\item[{char}]{val }\end{DoxyParamCaption})}



Function to push onto stack. 


\begin{DoxyParams}{Parameters}
{\em val} & \\
\hline
\end{DoxyParams}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{_task_8c_ac0744ec81e8bd93d084359202d422199}\label{_task_8c_ac0744ec81e8bd93d084359202d422199}} 
\index{Task.c@{Task.c}!noOfCharacters@{noOfCharacters}}
\index{noOfCharacters@{noOfCharacters}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{noOfCharacters}{noOfCharacters}}
{\footnotesize\ttfamily int no\+Of\+Characters = 0}

\mbox{\Hypertarget{_task_8c_ae24cff811e071e4fe46eff231506df71}\label{_task_8c_ae24cff811e071e4fe46eff231506df71}} 
\index{Task.c@{Task.c}!stack@{stack}}
\index{stack@{stack}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{stack}{stack}}
{\footnotesize\ttfamily char stack\mbox{[}\mbox{\hyperlink{_task_8c_a2e1da8593b0244d8e9e3b84ef7b35e73}{max}}\mbox{]}}



Create a stack to keep track of operators. 

\mbox{\Hypertarget{_task_8c_af93f4f37fc2ad9c37af4a715423b110c}\label{_task_8c_af93f4f37fc2ad9c37af4a715423b110c}} 
\index{Task.c@{Task.c}!top@{top}}
\index{top@{top}!Task.c@{Task.c}}
\doxysubsubsection{\texorpdfstring{top}{top}}
{\footnotesize\ttfamily int top = -\/1}

